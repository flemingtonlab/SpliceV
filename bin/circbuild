#!/usr/bin/env python
import sys
from collections import defaultdict
import sqlite3
import os
import argparse
import glob


# TODO: import fasta, store junction nucleotides

def parse_args():

    '''The only requirement is a gtf file. Provide an unstranded (or two stranded) wig file for coverage,
    a splice junction bed file for canonical splice junctions, and a backsplice junction bed file for circles.
    An output path is optional - if omitted, the db will be saved in the working directory.'''
    
    parser = argparse.ArgumentParser(description='Build database for use with "plot_transcript" script.', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("-g", "--gtf", required=True, dest='gtf_path', type=str, help="GTF path", metavar='')
    parser.add_argument("-wn", "--wigneg", dest='negwig', type=str, help="Negative strand wig path", metavar='')
    parser.add_argument("-wp", "--wigpos", dest='poswig', type=str, help='Positive strand wig path', metavar='')
    parser.add_argument("-w", "--wig", dest='wig', type=str, help='Unstranded wig path (Overrides "-wp" and "-wn")', metavar='')
    parser.add_argument("-sj", "--splicejunction", dest='sjbed', type=str, help='Canonical splice junction tab delimited bed file path. Order must be Chromosome, Start, Stop, Strand, Counts', metavar='') 
    parser.add_argument("-c", "--circlejunction", dest='circbed', type=str, help='Backsplice junction tab delimited bed file path. Order must be Chromosome, Start, Stop, Strand, Counts', metavar='')
    parser.add_argument("-o", "--output", type=str, dest='out', help='Output directory', metavar='')
    parser.add_argument("-f", "--fasta", nargs='*', type=str, dest='fasta', help='Path to genome fasta file or directory of fasta files.')
    args = parser.parse_args()

    return args

def index_fasta(path):
# NAME	Name of this reference sequence
# LENGTH	Total length of this reference sequence, in bases
# OFFSET	Offset in the FASTA/FASTQ file of this sequence's first base
# LINEBASES	The number of bases on each line
# LINEWIDTH	The number of bytes in each line, including the newline
    
    fa_ix = []
    f = open(path)
    name = offset = line_len = ini_stripped_line_len = stripped_line_len = 0
    total_seq_len = 0
    line = '_'
    set_name = False
    
    while line:

        if line[0] == '>':
            if name:
                fa_ix.append((name, total_seq_len, offset, ini_stripped_line_len, line_len))
            set_name = True
            line = line.strip()
            name = line.replace('>', '').split()[0]
            offset = f.tell()
            total_seq_len = 0
            print(line, f.tell())
            line = f.readline()
        
        elif set_name:
            line_len = len(line)
            ini_stripped_line_len = len(line.strip())  # Windows adds 2 bytes for newline char, others add 1
            set_name = False

        stripped_line_len = len(line.strip())
        total_seq_len += stripped_line_len

        line = f.readline()

    fa_ix.append((name, total_seq_len, offset, ini_stripped_line_len, line_len))
    seq_map = {}

    with open(path + '.fai', 'w') as index_file:
        for item in fa_ix:
            name = item[0]
            index_file.write('%s\n' % '\t'.join([str(j) for j in item]))
            seq_map[name] = path

    return seq_map

def prep_fasta(paths):
    # TODO: include function to download reference sequences (and ref gtfs?) - maybe have a dictionary of species
    seq_map = {}
    if len(paths) == 1:
        path = paths[0]
        if os.path.isdir(path):
            paths = glob.glob(os.path.join(path, '*.fa'))
            if len(paths) == 0:
                print("No fasta files found in directory '%s'. Make sure fasta files end in '.fa'." % path)
                return

    for path in paths:
        if path.endswith(".fa") and os.path.isfile(path):
            # Single genome fasta file with headers. Make sure indexed or index here
            fasta_index_path = path + '.fai'
            if not os.path.isfile(fasta_index_path):
                print("No fasta index, %s, found. Generating fasta index..." % fasta_index_path)

                temp_seq_map = index_fasta(path)
                seq_map = {**seq_map, **temp_seq_map}
    return seq_map

def rcomp(seq, reverse=True):
    
    dna = dict(zip('ATCG','TAGC'))
    seq = seq.upper()

    complement = ''.join([dna[i] if i in dna else i for i in seq])

    if reverse:
        return complement[::-1]
    
    return complement


def read_fasta(fa_path, chromosome, start, stop, strand):
    '''Requires path to indexed fasta file. Returns the nucleotide sequence'''

    fai_path = fa_path + '.fai'

    if not os.path.exists(fa_path):
        print("Fasta file %s was not found. Please make sure the path is correct and the file exists." % fa_path)
    
    if not os.path.exists(fai_path):
        print("Fasta index for %s was not found (%s). Please make sure the path is correct and the file exists. Indexing now.." % (fa_path, os.path.basename(fai_path)))
        index_fasta(fa_path)
      
    with open(fai_path, 'r') as fai:
        for line in fai:
            name, seq_len, offset, nbases_line, nbytes_line = line.strip().split('\t')

            if name == chromosome:  
                seq_len = int(seq_len)
                offset = int(offset)
                nbases_line = int(nbases_line)
                nbytes_line = int(nbytes_line)
                
                break
            
    start_offset = nbytes_line * start // nbases_line
    stop_offset = nbytes_line * stop // nbases_line
    if strand == '-':
        start_offset, stop_offset = stop_offset, start_offset

    start_offset -= 1
    seek_len = abs(stop_offset - start_offset)

    with open(fa_path, 'r') as fa:
        fa.seek(offset + start_offset)
        seq = fa.read(seek_len).replace('\n', '')
    if strand == '-':
        return rcomp(seq)
    return seq


def store(gtf_path, max_coord, interval):

    ''' Build a dictionary indexed by interval, with transcript info stored according to chromosomal coordinates.
    
    i.e. {
        chr1: {
            0: {
                'ENST000112341__1': (500, 1200, -, [], EGFR),
                }
            10000: {
                'ENST000351001__1': (10220, 14000, +, [], COL1A1)
            }
        },
        

    }

    Each key points to a tuple containing start, stop, strand, an empty list (to append coverage to while parsing wig file), and the gene name.    '''
    
    print("Loading gtf file..")
    line_num = 0

    master = {}
    with open(gtf_path) as gtf:
        for line in gtf:
            line_num += 1
            if line_num % 100000 == 0:
                print("%i lines processed" % line_num)

            if line[0] != '#':
                line = line.split('\t')
                chromosome = line[0]
            
                if line[2] != 'exon':
                    continue
            
                if chromosome not in master:
                    master[chromosome] = {i: {} for i in range(0, max_coord, interval)}             
            
                start = int(line[3])
                stop = int(line[4])
                strand = line[6]
            
                try:
                    gene = line[-1].split('gene_name')[1].split('"')[1]
                except IndexError:
                    gene = line[-1].split('gene_id')[1].split('"')[1]
            
                transcript = line[-1].split('transcript_id')[1].split('"')[1]
                exon = line[-1].split('exon_number ')[1].split(';')[0].replace('"','')
                exon_id = '__'.join([transcript, exon])
                entry = interval * (start // interval)
                master[chromosome][entry][exon_id]=[start, stop, strand, 0, gene]

    return master


def build_coverage_dict(master, wigpath, strand=False):
    
    not_found = []
    print("Storing coverage data from %s" % wigpath)
    line_num = 0
    with open(wigpath, "r") as wigfile:
        for line in wigfile:
            line_num += 1
            if line_num % 10000000 == 0:
                print("%i lines processed" % line_num)

            # Wig file lines beginning with "variable step=chrN" mark beginning of that chromosome 
            if line[0] == 'v':
                chromosome = line.strip('\n').split('=')[1]
                print("Chromosome:", chromosome) 

            else:            
                line_split = line.split("\t")   
                position = int(line_split[0])   
                coverage = float(line_split[1]) 
                primary = interval * (position // interval)  
                
                try:
                    if strand:         
                        for key, value in master[chromosome][primary].items():                      
                            if value[1] >= position >= value[0] and value[2] == strand:  
                                master[chromosome][primary][key][3]+=coverage
                    else:
                        for key, value in master[chromosome][primary].items():                    
                            if value[1] >= position >= value[0]:
                                master[chromosome][primary][key][3] += coverage

                except KeyError:                      
                    not_found.append(chromosome)
    if not_found:
        for i in set(not_found):
            print("%s was not found in your gtf file. Please make sure all files use the same annotation. Coverage for %s will not be included" %(i, i))


def build_sample_db(parsed_args):
  
    master = store(gtf_path, max_coord, interval)

    if parsed_args.wig:
        build_coverage_dict(master, parsed_args.wig)

    elif parsed_args.negwig and parsed_args.poswig: 
        build_coverage_dict(master, parsed_args.negwig, strand='-')
        build_coverage_dict(master, parsed_args.poswig, strand='+')

    table_name = 'coverage' 
    conn = sqlite3.connect('%s.db' % out)
    c = conn.cursor()
    try:
        c.execute("CREATE TABLE %s ( gene text, transcript text, exon int, coverage real, chromosome text, start int, stop int, strand text)" % table_name)
    except sqlite3.OperationalError:
        sys.exit("Database %s.db already exists. Please change the name of your output database or remove the conflicting database" % out)
    for chromosome in master:
        for position in master[chromosome]:
            for exon_id, values in master[chromosome][position].items():
                transcript, exon = exon_id.split('__')
                start, stop, strand, base_coverage, gene = values
                coverage = base_coverage / float(1 + stop - start) 
                c.execute("INSERT INTO %s VALUES(?,?,?,?,?,?,?,?)" % table_name, (gene, transcript, exon, coverage, chromosome, start, stop, strand))
    
    conn.commit()
    conn.close()


def build_junction_table(bed_path, table_name):

    print("Building junction table %s" % table_name)
    conn = sqlite3.connect('%s.db' % out)
    c = conn.cursor()
    c.execute("CREATE TABLE %s ( chromosome text, start int, stop int, strand text, counts int)" % table_name)

    with open(bed_path, "r") as input_file:
        for line in input_file:
            line = line.strip().split()
            chromosome, start, stop, strand, counts = line[:5]
            start = int(start) + 1  # Bed format is 0 indexed
            stop = int(stop) + 1
            c.execute("INSERT INTO %s VALUES(?,?,?,?,?)" % table_name, (chromosome, start, stop, strand, counts))

    conn.commit()
    conn.close()


if __name__ == '__main__':

#    if sys.version_info[0] < 3:
 #       raise Exception("Must be using Python 3")

    args = parse_args()
    gtf_path = args.gtf_path
    out = args.out

    if os.path.isfile(os.path.realpath('%s.db' % out)):
        sys.exit('\n"%s.db" is an existing database. For this program to run, you must change the "--output" argument or delete the existing database\n' % out)
    try:
        conn = sqlite3.connect('%s.db' % out)
    except sqlite3.OperationalError:
        sys.exit("%s.db cannot be opened." % out)

    conn.close()

    max_coord = 400000000   # If there is a chromosome larger than this, increase this number
    interval = 10000  
    #for handle in args:
    #   if not os.path.exists(handle):
    #      sys.exit(("{} was not found".format(handle)))

    build_sample_db(parsed_args=args)
    build_junction_table(bed_path=args.sjbed, table_name="canonical")
    build_junction_table(bed_path=args.circbed, table_name="circle")

